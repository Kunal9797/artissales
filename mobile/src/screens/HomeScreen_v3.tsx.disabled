/**
 * HomeScreen v3 (Sales Rep Dashboard) - No Attendance, Unified Activity Feed
 *
 * Key Changes from v2:
 * - NO attendance tracking (check-in/check-out removed)
 * - 3 KPI cards only (Visits, Sheets, Expenses)
 * - Unified activity timeline (last 100 activities with pagination)
 * - DSR approval status shown inline as badges
 * - Manager feedback visible directly on rejected items
 * - Cleaner, simpler UX focused on actual work
 */

import React, { useState, useEffect, useCallback } from 'react';
import { logger } from '../utils/logger';
import {
  View,
  Text,
  TouchableOpacity,
  StyleSheet,
  ScrollView,
  RefreshControl,
  ActivityIndicator,
  FlatList,
} from 'react-native';
import { getAuth } from '@react-native-firebase/auth';
import { getFirestore, doc, getDoc, collection, query, where, orderBy, limit, getDocs } from '@react-native-firebase/firestore';
import { Card, Badge } from '../components/ui';
import { KpiCard } from '../patterns/KpiCard';
import { colors, spacing, typography, featureColors, shadows, roles } from '../theme';
import { getGreeting } from '../utils/greeting';
import { useBottomSafeArea } from '../hooks/useBottomSafeArea';
import {
  MapPin,
  IndianRupee,
  FileText,
  ChevronRight,
  Plus,
  AlertCircle,
  CheckCircle2,
  Clock,
} from 'lucide-react-native';

interface HomeScreenV3Props {
  navigation: any;
}

interface Activity {
  id: string;
  type: 'visit' | 'sheets' | 'expense';
  timestamp: Date;
  date: string; // YYYY-MM-DD
  description: string;
  subtitle?: string;
  amount?: number;
  dsrStatus?: 'pending' | 'approved' | 'needs_revision';
  managerComments?: string;
  data: any; // Original Firestore doc data
}

export const HomeScreenV3: React.FC<HomeScreenV3Props> = ({ navigation }) => {
  const authInstance = getAuth();
  const user = authInstance.currentUser;
  const bottomPadding = useBottomSafeArea(12);

  // State
  const [userName, setUserName] = useState<string>('');
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  // KPI Stats
  const [kpiStats, setKpiStats] = useState({
    visits: 0,
    sheets: 0,
    expenses: 0,
  });

  // Activity Timeline
  const [activities, setActivities] = useState<Activity[]>([]);
  const [loadingActivities, setLoadingActivities] = useState(false);
  const [hasMoreActivities, setHasMoreActivities] = useState(true);
  const [activityPage, setActivityPage] = useState(1);
  const ACTIVITIES_PER_PAGE = 20;
  const MAX_ACTIVITIES = 100;

  // Fetch user profile
  useEffect(() => {
    if (!user?.uid) return;

    const fetchUserProfile = async () => {
      try {
        const firestore = getFirestore();
        const userDoc = await getDoc(doc(firestore, 'users', user.uid));

        if (userDoc.exists()) {
          const userData = userDoc.data();
          setUserName(userData.name || 'there');
        }
      } catch (error) {
        logger.error('Error fetching user profile:', error);
      }
    };

    fetchUserProfile();
  }, [user?.uid]);

  // Fetch today's KPI stats
  const fetchKpiStats = useCallback(async () => {
    if (!user?.uid) return;

    try {
      const firestore = getFirestore();
      const today = new Date().toISOString().split('T')[0];
      const startOfDay = new Date(`${today}T00:00:00`);
      const endOfDay = new Date(`${today}T23:59:59`);

      // Parallel fetch for performance
      const [visitsSnapshot, sheetsSnapshot, expensesSnapshot] = await Promise.all([
        // Today's visits
        getDocs(query(
          collection(firestore, 'visits'),
          where('userId', '==', user.uid),
          where('timestamp', '>=', startOfDay),
          where('timestamp', '<=', endOfDay)
        )),

        // Today's sheets
        getDocs(query(
          collection(firestore, 'sheetsSales'),
          where('userId', '==', user.uid),
          where('date', '==', today)
        )),

        // Today's expenses
        getDocs(query(
          collection(firestore, 'expenses'),
          where('userId', '==', user.uid),
          where('date', '==', today)
        )),
      ]);

      // Calculate totals
      const totalSheets = sheetsSnapshot.docs.reduce((sum, doc) => {
        return sum + (doc.data().sheetsCount || 0);
      }, 0);

      const totalExpenses = expensesSnapshot.docs.reduce((sum, doc) => {
        return sum + (doc.data().totalAmount || 0);
      }, 0);

      setKpiStats({
        visits: visitsSnapshot.size,
        sheets: totalSheets,
        expenses: totalExpenses,
      });
    } catch (error) {
      logger.error('Error fetching KPI stats:', error);
    }
  }, [user?.uid]);

  // Fetch activity timeline (last 100 activities with pagination)
  const fetchActivities = useCallback(async (pageNumber: number = 1) => {
    if (!user?.uid) return;

    setLoadingActivities(true);

    try {
      const firestore = getFirestore();
      const activitiesPerFetch = ACTIVITIES_PER_PAGE;

      // Fetch from all 3 collections
      const [visitsSnapshot, sheetsSnapshot, expensesSnapshot, dsrSnapshot] = await Promise.all([
        // Visits (last 50)
        getDocs(query(
          collection(firestore, 'visits'),
          where('userId', '==', user.uid),
          orderBy('timestamp', 'desc'),
          limit(50)
        )),

        // Sheets (last 50) - using 'date' field which is indexed
        getDocs(query(
          collection(firestore, 'sheetsSales'),
          where('userId', '==', user.uid),
          orderBy('date', 'desc'),
          limit(50)
        )),

        // Expenses (last 50) - using 'date' field which is indexed
        getDocs(query(
          collection(firestore, 'expenses'),
          where('userId', '==', user.uid),
          orderBy('date', 'desc'),
          limit(50)
        )),

        // DSR reports (last 30 days) - for approval status
        getDocs(query(
          collection(firestore, 'dsrReports'),
          where('userId', '==', user.uid),
          orderBy('date', 'desc'),
          limit(30)
        )),
      ]);

      // Build DSR status lookup map (date -> DSR report)
      const dsrByDate = new Map();
      dsrSnapshot.docs.forEach(doc => {
        const data = doc.data();
        dsrByDate.set(data.date, {
          status: data.status,
          managerComments: data.managerComments,
        });
      });

      // Convert visits to activities
      const visitActivities: Activity[] = visitsSnapshot.docs.map(doc => {
        const data = doc.data();
        const timestamp = data.timestamp?.toDate() || new Date();
        const dateStr = timestamp.toISOString().split('T')[0];
        const dsr = dsrByDate.get(dateStr);

        return {
          id: doc.id,
          type: 'visit',
          timestamp,
          date: dateStr,
          description: `Visit - ${data.accountName}`,
          subtitle: `${data.accountType} ‚Ä¢ ${data.purpose}`,
          dsrStatus: dsr?.status,
          managerComments: dsr?.managerComments,
          data,
        };
      });

      // Convert sheets to activities
      const sheetsActivities: Activity[] = sheetsSnapshot.docs.map(doc => {
        const data = doc.data();
        const dateStr = data.date;
        // Parse date string to create timestamp (default to start of day)
        const timestamp = data.createdAt?.toDate() || new Date(dateStr + 'T12:00:00');
        const dsr = dsrByDate.get(dateStr);

        return {
          id: doc.id,
          type: 'sheets',
          timestamp,
          date: dateStr,
          description: `Sheets - ${data.sheetsCount} ${data.catalog}`,
          subtitle: data.distributorName ? `Via: ${data.distributorName}` : undefined,
          dsrStatus: dsr?.status,
          managerComments: dsr?.managerComments,
          data,
        };
      });

      // Convert expenses to activities
      const expenseActivities: Activity[] = expensesSnapshot.docs.map(doc => {
        const data = doc.data();
        const dateStr = data.date;
        // Parse date string to create timestamp (default to start of day)
        const timestamp = data.createdAt?.toDate() || new Date(dateStr + 'T12:00:00');
        const dsr = dsrByDate.get(dateStr);

        return {
          id: doc.id,
          type: 'expense',
          timestamp,
          date: dateStr,
          description: `Expense - ‚Çπ${data.totalAmount}`,
          subtitle: `${data.items?.length || 0} items`,
          amount: data.totalAmount,
          dsrStatus: dsr?.status,
          managerComments: dsr?.managerComments,
          data,
        };
      });

      // Merge all activities and sort by timestamp (newest first)
      const allActivities = [...visitActivities, ...sheetsActivities, ...expenseActivities]
        .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
        .slice(0, MAX_ACTIVITIES); // Cap at 100 total

      // Pagination logic
      const startIndex = (pageNumber - 1) * activitiesPerFetch;
      const endIndex = startIndex + activitiesPerFetch;
      const paginatedActivities = allActivities.slice(startIndex, endIndex);

      if (pageNumber === 1) {
        setActivities(paginatedActivities);
      } else {
        setActivities(prev => [...prev, ...paginatedActivities]);
      }

      setHasMoreActivities(endIndex < allActivities.length);
      setActivityPage(pageNumber);
    } catch (error) {
      logger.error('Error fetching activities:', error);
    } finally {
      setLoadingActivities(false);
    }
  }, [user?.uid]);

  // Initial load
  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      await Promise.all([fetchKpiStats(), fetchActivities(1)]);
      setLoading(false);
    };

    loadData();
  }, [fetchKpiStats, fetchActivities]);

  // Pull to refresh
  const handleRefresh = useCallback(async () => {
    setRefreshing(true);
    await Promise.all([fetchKpiStats(), fetchActivities(1)]);
    setRefreshing(false);
  }, [fetchKpiStats, fetchActivities]);

  // Load more activities (pagination)
  const handleLoadMore = useCallback(() => {
    if (!loadingActivities && hasMoreActivities) {
      fetchActivities(activityPage + 1);
    }
  }, [loadingActivities, hasMoreActivities, activityPage, fetchActivities]);

  // Render activity badge based on DSR status
  const renderStatusBadge = (status?: string) => {
    if (!status) return null;

    switch (status) {
      case 'pending':
        return <Badge variant="warning" size="sm">PENDING APPROVAL</Badge>;
      case 'approved':
        return <Badge variant="success" size="sm">APPROVED ‚úì</Badge>;
      case 'needs_revision':
        return <Badge variant="error" size="sm">NEEDS REVISION ‚ö†Ô∏è</Badge>;
      default:
        return null;
    }
  };

  // Render activity icon
  const renderActivityIcon = (type: string) => {
    switch (type) {
      case 'visit':
        return <MapPin size={20} color={featureColors.visits} />;
      case 'sheets':
        return <FileText size={20} color={featureColors.sheets} />;
      case 'expense':
        return <IndianRupee size={20} color={featureColors.expenses} />;
      default:
        return null;
    }
  };

  // Group activities by date
  const groupedActivities = activities.reduce((groups, activity) => {
    const dateKey = activity.date;
    if (!groups[dateKey]) {
      groups[dateKey] = [];
    }
    groups[dateKey].push(activity);
    return groups;
  }, {} as Record<string, Activity[]>);

  // Format date header
  const formatDateHeader = (dateStr: string) => {
    const today = new Date().toISOString().split('T')[0];
    const yesterday = new Date(Date.now() - 86400000).toISOString().split('T')[0];

    if (dateStr === today) return 'TODAY';
    if (dateStr === yesterday) return 'YESTERDAY';

    const date = new Date(dateStr);
    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  };

  // Render activity item
  const renderActivityItem = (activity: Activity) => (
    <TouchableOpacity
      key={activity.id}
      style={styles.activityCard}
      onPress={() => {
        // Navigate to detail/edit screen based on status
        if (activity.dsrStatus === 'needs_revision') {
          // Navigate to edit screen
          if (activity.type === 'visit') {
            navigation.navigate('EditVisit', { visitId: activity.id });
          } else if (activity.type === 'sheets') {
            navigation.navigate('EditSheets', { sheetId: activity.id });
          } else if (activity.type === 'expense') {
            navigation.navigate('EditExpense', { expenseId: activity.id });
          }
        } else {
          // Navigate to view-only detail screen
          // TODO: Implement detail screens
        }
      }}
    >
      <View style={styles.activityHeader}>
        <View style={styles.activityIconTime}>
          {renderActivityIcon(activity.type)}
          <Text style={styles.activityTime}>
            {activity.timestamp.toLocaleTimeString('en-US', {
              hour: '2-digit',
              minute: '2-digit',
            })}
          </Text>
        </View>
        {renderStatusBadge(activity.dsrStatus)}
      </View>

      <Text style={styles.activityTitle}>{activity.description}</Text>
      {activity.subtitle && (
        <Text style={styles.activitySubtitle}>{activity.subtitle}</Text>
      )}

      {/* Manager feedback for rejected items */}
      {activity.dsrStatus === 'needs_revision' && activity.managerComments && (
        <View style={styles.managerFeedback}>
          <AlertCircle size={16} color={roles.error.base} />
          <View style={styles.feedbackTextContainer}>
            <Text style={styles.feedbackLabel}>Manager feedback:</Text>
            <Text style={styles.feedbackText}>{activity.managerComments}</Text>
          </View>
        </View>
      )}

      <View style={styles.activityFooter}>
        <Text style={styles.viewDetails}>
          {activity.dsrStatus === 'needs_revision' ? 'Tap to edit' : 'View details'}
        </Text>
        <ChevronRight size={16} color={colors.text.tertiary} />
      </View>
    </TouchableOpacity>
  );

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={colors.accent} />
        <Text style={styles.loadingText}>Loading dashboard...</Text>
      </View>
    );
  }

  return (
    <ScrollView
      style={styles.container}
      contentContainerStyle={[styles.content, { paddingBottom: bottomPadding }]}
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
      }
    >
      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.greeting}>{getGreeting().text}, {userName}! üëã</Text>
        <Text style={styles.subGreeting}>Let's make today productive!</Text>
      </View>

      {/* KPI Cards (3 cards) */}
      <View style={styles.kpiGrid}>
        <View style={styles.kpiCard}>
          <KpiCard
            title="Visits"
            value={kpiStats.visits}
            icon={<MapPin size={24} color={featureColors.visits} />}
          />
        </View>
        <View style={styles.kpiCard}>
          <KpiCard
            title="Sheets"
            value={kpiStats.sheets}
            icon={<FileText size={24} color={featureColors.sheets} />}
          />
        </View>
        <View style={styles.kpiCard}>
          <KpiCard
            title="Expenses"
            value={`‚Çπ${kpiStats.expenses}`}
            icon={<IndianRupee size={24} color={featureColors.expenses} />}
          />
        </View>
      </View>

      {/* Quick Actions */}
      <View style={styles.quickActions}>
        <TouchableOpacity
          style={[styles.actionButton, { backgroundColor: featureColors.visits }]}
          onPress={() => navigation.navigate('LogVisit')}
        >
          <Plus size={20} color="#FFFFFF" />
          <Text style={styles.actionButtonText}>Log Visit</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.actionButton, { backgroundColor: featureColors.sheets }]}
          onPress={() => navigation.navigate('LogSheets')}
        >
          <Plus size={20} color="#FFFFFF" />
          <Text style={styles.actionButtonText}>Add Sheets</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.actionButton, { backgroundColor: featureColors.expenses }]}
          onPress={() => navigation.navigate('LogExpense')}
        >
          <Plus size={20} color="#FFFFFF" />
          <Text style={styles.actionButtonText}>Add Expense</Text>
        </TouchableOpacity>
      </View>

      {/* Activity Timeline */}
      <View style={styles.timelineContainer}>
        <Text style={styles.sectionTitle}>Activity Timeline</Text>

        {activities.length === 0 ? (
          <Card style={styles.emptyState}>
            <Clock size={48} color={colors.text.tertiary} />
            <Text style={styles.emptyStateText}>No activities yet</Text>
            <Text style={styles.emptyStateSubtext}>
              Log your first visit, sheet sale, or expense to get started
            </Text>
          </Card>
        ) : (
          <>
            {Object.entries(groupedActivities).map(([date, dateActivities]) => (
              <View key={date} style={styles.dateGroup}>
                <View style={styles.dateHeader}>
                  <View style={styles.dateLine} />
                  <Text style={styles.dateHeaderText}>{formatDateHeader(date)}</Text>
                  <View style={styles.dateLine} />
                </View>

                {dateActivities.map(renderActivityItem)}
              </View>
            ))}

            {/* Load More Button */}
            {hasMoreActivities && (
              <TouchableOpacity
                style={styles.loadMoreButton}
                onPress={handleLoadMore}
                disabled={loadingActivities}
              >
                {loadingActivities ? (
                  <ActivityIndicator size="small" color={colors.accent} />
                ) : (
                  <>
                    <Text style={styles.loadMoreText}>Load More Activities</Text>
                    <ChevronRight size={16} color={colors.accent} />
                  </>
                )}
              </TouchableOpacity>
            )}

            {!hasMoreActivities && activities.length >= ACTIVITIES_PER_PAGE && (
              <Text style={styles.endOfListText}>
                You've reached the end (showing last 100 activities)
              </Text>
            )}
          </>
        )}
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background.primary,
  },
  content: {
    paddingHorizontal: spacing.md,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: colors.background.primary,
  },
  loadingText: {
    marginTop: spacing.md,
    ...typography.body,
    color: colors.text.secondary,
  },

  // Header
  header: {
    paddingTop: spacing.xl,
    paddingBottom: spacing.md,
  },
  greeting: {
    ...typography.h2,
    color: colors.text.primary,
    marginBottom: spacing.xs,
  },
  subGreeting: {
    ...typography.body,
    color: colors.text.secondary,
  },

  // KPI Grid
  kpiGrid: {
    flexDirection: 'row',
    gap: spacing.sm,
    marginBottom: spacing.lg,
  },
  kpiCard: {
    flex: 1,
  },

  // Quick Actions
  quickActions: {
    flexDirection: 'row',
    gap: spacing.sm,
    marginBottom: spacing.xl,
  },
  actionButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: spacing.md,
    paddingHorizontal: spacing.sm,
    borderRadius: 8,
    gap: spacing.xs,
  },
  actionButtonText: {
    ...typography.bodyMedium,
    color: '#FFFFFF',
    fontSize: 13,
  },

  // Timeline
  timelineContainer: {
    marginBottom: spacing.xl,
  },
  sectionTitle: {
    ...typography.h3,
    color: colors.text.primary,
    marginBottom: spacing.md,
  },
  dateGroup: {
    marginBottom: spacing.lg,
  },
  dateHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: spacing.md,
    gap: spacing.sm,
  },
  dateLine: {
    flex: 1,
    height: 1,
    backgroundColor: colors.border.primary,
  },
  dateHeaderText: {
    ...typography.caption,
    color: colors.text.secondary,
    fontWeight: '600',
    letterSpacing: 1,
  },

  // Activity Card
  activityCard: {
    backgroundColor: colors.background.secondary,
    borderRadius: 12,
    padding: spacing.md,
    marginBottom: spacing.sm,
    ...shadows.sm,
  },
  activityHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: spacing.sm,
  },
  activityIconTime: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: spacing.sm,
  },
  activityTime: {
    ...typography.caption,
    color: colors.text.secondary,
  },
  activityTitle: {
    ...typography.bodyMedium,
    color: colors.text.primary,
    marginBottom: spacing.xs,
  },
  activitySubtitle: {
    ...typography.caption,
    color: colors.text.secondary,
  },
  managerFeedback: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    backgroundColor: roles.error.background,
    borderLeftWidth: 3,
    borderLeftColor: roles.error.base,
    padding: spacing.sm,
    marginTop: spacing.sm,
    borderRadius: 6,
    gap: spacing.sm,
  },
  feedbackTextContainer: {
    flex: 1,
  },
  feedbackLabel: {
    ...typography.caption,
    color: roles.error.text,
    fontWeight: '600',
    marginBottom: spacing.xxs,
  },
  feedbackText: {
    ...typography.caption,
    color: roles.error.text,
  },
  activityFooter: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'flex-end',
    marginTop: spacing.sm,
    gap: spacing.xxs,
  },
  viewDetails: {
    ...typography.caption,
    color: colors.text.tertiary,
  },

  // Load More
  loadMoreButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: spacing.md,
    backgroundColor: colors.background.secondary,
    borderRadius: 8,
    marginTop: spacing.md,
    gap: spacing.xs,
  },
  loadMoreText: {
    ...typography.bodyMedium,
    color: colors.accent,
  },
  endOfListText: {
    ...typography.caption,
    color: colors.text.tertiary,
    textAlign: 'center',
    marginTop: spacing.md,
  },

  // Empty State
  emptyState: {
    alignItems: 'center',
    padding: spacing.xl,
  },
  emptyStateText: {
    ...typography.bodyMedium,
    color: colors.text.secondary,
    marginTop: spacing.md,
  },
  emptyStateSubtext: {
    ...typography.caption,
    color: colors.text.tertiary,
    marginTop: spacing.xs,
    textAlign: 'center',
  },
});
